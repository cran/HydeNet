<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>    toc: no</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Decision Networks}
-->

<hr/>

<p>title: &ldquo;Decision Network (Influence Diagram) Analyses in HydeNet&rdquo;
author: &ldquo;Jarrod Dalton and Benjamin Nutter&rdquo;
date: &ldquo;24 Apr 2015&rdquo;
output:
  html_document:
    fig_caption: yes
    number_section: yes
    toc: yes
  pdf_document:
    fig_caption: yes
    number_section: yes</p>

<h2>    toc: no</h2>

<p>Decision networks are Bayesian networks where a subset of nodes represents <em>decisions</em> that may be chosen by an actor (or actors) and another subset of nodes represents <em>utilities</em> associated with certain outcomes. These networks are commonly referred to in the literature as <em>influence diagrams</em>. </p>

<h2>Example Decison Network: Blackjack</h2>

<p>In the ensuing discussion, we will use the casino game blackjack as our primary example of an influence diagram model. In blackjack, two cards are dealt to both the player and the dealer. Points are assigned to each card as follows:</p>

<table><thead>
<tr>
<th align="left">Card</th>
<th align="left">Points</th>
</tr>
</thead><tbody>
<tr>
<td align="left">2 through 9</td>
<td align="left">Face Value</td>
</tr>
<tr>
<td align="left">Ten, Jack, Queen or King</td>
<td align="left">10 Points</td>
</tr>
<tr>
<td align="left">Ace</td>
<td align="left">1 or 11 points (player choice)</td>
</tr>
</tbody></table>

<p>For the dealer, one card (called the <em>upcard</em>) is dealt face up and the other is dealt face down. Thus, the player has only information on the upcard to guide decision-making. In the most basic form of the game (i.e., ignoring double-down, insurance and split decisions), the player is faced with the decision to <em>hit</em> or <em>stand</em>.  If the player chooses to hit, they are dealt another card and the points on that card are added to the player&#39;s previous total points.  If the total points adds to an amount greater than 21, the player <em>busts</em> (i.e., loses their money). Otherwise, the player is given another decision to hit or stand. This process continues until the player is either happy with their point total or they bust.  Once the player is all done taking cards (again, assuming they haven&#39;t busted), the dealer deals itself cards until its total is greater than or equal to 17 or it has busted. </p>

<p>We have included some blackjack hand data in the package (data frame object <code>BlackJackTrain</code>) to demonstrate the process of populating these decision nodes. These data are completely fake, so results of our analysis should not be operationalized at the casino; besides, even the optimal &ldquo;basic strategy&rdquo; of deciding when and when not to take another card results in a net expected loss. Below is a somewhat unlucky sample of the dataset:</p>

<table><thead>
<tr>
<th align="left">dealerUpcard</th>
<th align="left">card1</th>
<th align="left">card2</th>
<th align="right">initialPoints</th>
<th align="right">hit1</th>
<th align="left">card3</th>
<th align="right">pointsAfterCard3</th>
<th align="right">hit2</th>
<th align="left">card4</th>
<th align="right">pointsAfterCard4</th>
<th align="right">hit3</th>
</tr>
</thead><tbody>
<tr>
<td align="left">10-K</td>
<td align="left">6</td>
<td align="left">4</td>
<td align="right">10</td>
<td align="right">1</td>
<td align="left">2</td>
<td align="right">12</td>
<td align="right">1</td>
<td align="left">10-K</td>
<td align="right">22</td>
<td align="right"></td>
</tr>
<tr>
<td align="left">10-K</td>
<td align="left">5</td>
<td align="left">9</td>
<td align="right">14</td>
<td align="right">0</td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">8</td>
<td align="left">10-K</td>
<td align="right">18</td>
<td align="right">0</td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">7</td>
<td align="left">10-K</td>
<td align="right">17</td>
<td align="right">0</td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">9</td>
<td align="left">5</td>
<td align="right">14</td>
<td align="right">1</td>
<td align="left">2</td>
<td align="right">16</td>
<td align="right">0</td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">10-K</td>
<td align="left">A</td>
<td align="left">2</td>
<td align="right">13</td>
<td align="right">0</td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">10-K</td>
<td align="left">10-K</td>
<td align="right">20</td>
<td align="right">0</td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">10-K</td>
<td align="left">8</td>
<td align="right">18</td>
<td align="right">0</td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">5</td>
<td align="right">9</td>
<td align="right">1</td>
<td align="left">A</td>
<td align="right">20</td>
<td align="right">0</td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">10-K</td>
<td align="left">8</td>
<td align="left">5</td>
<td align="right">13</td>
<td align="right">1</td>
<td align="left">10-K</td>
<td align="right">23</td>
<td align="right"></td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">10-K</td>
<td align="left">5</td>
<td align="left">4</td>
<td align="right">9</td>
<td align="right">1</td>
<td align="left">5</td>
<td align="right">14</td>
<td align="right">1</td>
<td align="left">6</td>
<td align="right">20</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">A</td>
<td align="left">8</td>
<td align="left">8</td>
<td align="right">16</td>
<td align="right">0</td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">10-K</td>
<td align="left">10-K</td>
<td align="left">10-K</td>
<td align="right">20</td>
<td align="right">0</td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">10-K</td>
<td align="left">10-K</td>
<td align="left">10-K</td>
<td align="right">20</td>
<td align="right">0</td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">2</td>
<td align="left">6</td>
<td align="right">8</td>
<td align="right">1</td>
<td align="left">A</td>
<td align="right">19</td>
<td align="right">0</td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">10-K</td>
<td align="left">10-K</td>
<td align="left">5</td>
<td align="right">15</td>
<td align="right">0</td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">A</td>
<td align="left">4</td>
<td align="right">15</td>
<td align="right">1</td>
<td align="left">5</td>
<td align="right">20</td>
<td align="right">0</td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">5</td>
<td align="left">10-K</td>
<td align="right">15</td>
<td align="right">0</td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">10-K</td>
<td align="left">6</td>
<td align="left">10-K</td>
<td align="right">16</td>
<td align="right">0</td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">6</td>
<td align="left">10-K</td>
<td align="right">16</td>
<td align="right">1</td>
<td align="left">10-K</td>
<td align="right">26</td>
<td align="right"></td>
<td align="left"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
</tbody></table>

<p>To begin the modeling, we first construct a skeleton <code>HydeNet</code> model object, (i.e., a graphical model for which node characteristics have not yet been populated. See our vignette titled &ldquo;Working with HydeNetwork Objects&rdquo; for a general overview of network construction.</p>

<pre><code class="r">net &lt;- HydeNetwork(~ initialAces | card1*card2
                   + initialPoints | card1*card2
                   + highUpcard | dealerUpcard
                   + hit1 | initialPoints*highUpcard
                   + acesAfterCard3 | initialAces*card3
                   + pointsAfterCard3 | card1*card2*card3*acesAfterCard3
                   + hit2 | pointsAfterCard3*highUpcard
                   + acesAfterCard4 | acesAfterCard3*card4
                   + pointsAfterCard4 | card1*card2*card3*card4*acesAfterCard4
                   + hit3 | pointsAfterCard4*highUpcard
                   + acesAfterCard5 | acesAfterCard4*card5
                   + pointsAfterCard5 | card1*card2*card3*card4*card5*acesAfterCard5
                   + playerFinalPoints | initialPoints*hit1*pointsAfterCard3
                                         *hit2*pointsAfterCard4*hit3*pointsAfterCard5
                   + dealerOutcome | dealerUpcard
                   + payoff | playerFinalPoints*dealerOutcome)

plot(net)
</code></pre>

<pre><code>## Note: the specification for S3 class &quot;AsIs&quot; in package &#39;jsonlite&#39; seems equivalent to one from package &#39;BiocGenerics&#39;: not turning on duplicate class definitions for this class.
</code></pre>

<p>&lt;!&ndash;html_preserve&ndash;&gt;<div id="htmlwidget-6412" style="width:504px;height:504px;" class="grViz"></div>
<script type="application/json" data-for="htmlwidget-6412">{&quot;x&quot;:{&quot;diagram&quot;:&quot;digraph {\n\n  \&quot;initialAces\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;card1\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;card2\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;initialPoints\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;highUpcard\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;dealerUpcard\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;hit1\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;acesAfterCard3\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;card3\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;pointsAfterCard3\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;hit2\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;acesAfterCard4\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;card4\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;pointsAfterCard4\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;hit3\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;acesAfterCard5\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;card5\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;pointsAfterCard5\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;playerFinalPoints\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;dealerOutcome\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;payoff\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;card1\&quot;-&gt;\&quot;initialAces\&quot; \n  \&quot;card2\&quot;-&gt;\&quot;initialAces\&quot; \n  \&quot;card1\&quot;-&gt;\&quot;initialPoints\&quot; \n  \&quot;card2\&quot;-&gt;\&quot;initialPoints\&quot; \n  \&quot;dealerUpcard\&quot;-&gt;\&quot;highUpcard\&quot; \n  \&quot;initialPoints\&quot;-&gt;\&quot;hit1\&quot; \n  \&quot;highUpcard\&quot;-&gt;\&quot;hit1\&quot; \n  \&quot;initialAces\&quot;-&gt;\&quot;acesAfterCard3\&quot; \n  \&quot;card3\&quot;-&gt;\&quot;acesAfterCard3\&quot; \n  \&quot;card1\&quot;-&gt;\&quot;pointsAfterCard3\&quot; \n  \&quot;card2\&quot;-&gt;\&quot;pointsAfterCard3\&quot; \n  \&quot;acesAfterCard3\&quot;-&gt;\&quot;pointsAfterCard3\&quot; \n  \&quot;card3\&quot;-&gt;\&quot;pointsAfterCard3\&quot; \n  \&quot;highUpcard\&quot;-&gt;\&quot;hit2\&quot; \n  \&quot;pointsAfterCard3\&quot;-&gt;\&quot;hit2\&quot; \n  \&quot;acesAfterCard3\&quot;-&gt;\&quot;acesAfterCard4\&quot; \n  \&quot;card4\&quot;-&gt;\&quot;acesAfterCard4\&quot; \n  \&quot;card1\&quot;-&gt;\&quot;pointsAfterCard4\&quot; \n  \&quot;card2\&quot;-&gt;\&quot;pointsAfterCard4\&quot; \n  \&quot;card3\&quot;-&gt;\&quot;pointsAfterCard4\&quot; \n  \&quot;acesAfterCard4\&quot;-&gt;\&quot;pointsAfterCard4\&quot; \n  \&quot;card4\&quot;-&gt;\&quot;pointsAfterCard4\&quot; \n  \&quot;highUpcard\&quot;-&gt;\&quot;hit3\&quot; \n  \&quot;pointsAfterCard4\&quot;-&gt;\&quot;hit3\&quot; \n  \&quot;acesAfterCard4\&quot;-&gt;\&quot;acesAfterCard5\&quot; \n  \&quot;card5\&quot;-&gt;\&quot;acesAfterCard5\&quot; \n  \&quot;card1\&quot;-&gt;\&quot;pointsAfterCard5\&quot; \n  \&quot;card2\&quot;-&gt;\&quot;pointsAfterCard5\&quot; \n  \&quot;card3\&quot;-&gt;\&quot;pointsAfterCard5\&quot; \n  \&quot;card4\&quot;-&gt;\&quot;pointsAfterCard5\&quot; \n  \&quot;acesAfterCard5\&quot;-&gt;\&quot;pointsAfterCard5\&quot; \n  \&quot;card5\&quot;-&gt;\&quot;pointsAfterCard5\&quot; \n  \&quot;initialPoints\&quot;-&gt;\&quot;playerFinalPoints\&quot; \n  \&quot;hit1\&quot;-&gt;\&quot;playerFinalPoints\&quot; \n  \&quot;pointsAfterCard3\&quot;-&gt;\&quot;playerFinalPoints\&quot; \n  \&quot;hit2\&quot;-&gt;\&quot;playerFinalPoints\&quot; \n  \&quot;pointsAfterCard4\&quot;-&gt;\&quot;playerFinalPoints\&quot; \n  \&quot;hit3\&quot;-&gt;\&quot;playerFinalPoints\&quot; \n  \&quot;pointsAfterCard5\&quot;-&gt;\&quot;playerFinalPoints\&quot; \n  \&quot;dealerUpcard\&quot;-&gt;\&quot;dealerOutcome\&quot; \n  \&quot;playerFinalPoints\&quot;-&gt;\&quot;payoff\&quot; \n  \&quot;dealerOutcome\&quot;-&gt;\&quot;payoff\&quot; \n}&quot;,&quot;config&quot;:{&quot;engine&quot;:&quot;dot&quot;,&quot;options&quot;:null}},&quot;evals&quot;:[]}</script>&lt;!&ndash;/html_preserve&ndash;&gt;</p>

<p>Notice in the above network plot that all nodes have the same representation of empty black ovals. The <code>plot.HydeNetwork()</code> function allows for enhanced visualization of decision networks (see the vignette titled &ldquo;Building and Customizing HydeNet Plots&rdquo; for details; <code>vignette(&quot;HydeNetPlots&quot;, package=&quot;HydeNet&quot;)</code>), and since we have not yet specified the node types (i.e., random variable, deterministic, decision, or utility), it assumes that all nodes are random variables. Once we populate the network object with the node types and conditional distributions/deterministic functions, we will regenerate the plot.</p>

<p>First, we will populate the random variable and deterministic nodes using <code>setNode()</code> and <code>setNodeModels()</code>. Note that the deterministic node calculations are tedious due to the fact that an ace may mean 1 or 11 points depending on the other cards in the hand; we include the code for completeness but note that understanding the calculations are not critical to the general topic of decision networks.</p>

<pre><code class="r">#####################################
# Random Variable Nodes
#####################################

# Note: The calls to &#39;setNode&#39; below are going to generate messages
#       that validation has been ignored.  &#39;setNode&#39; assumes that when
#       you pass a character string as a parameter definition, you 
#       are passing JAGS code.  See the Validation section of the 
#       &#39;setNode&#39; documentation for more information.
#       After the first call, we&#39;ll turn off validation

cardProbs  &lt;- c(rep(1/13,8), 4/13, 1/13)  # probs. for 2, 3, ..., 9, (10-K), A

net &lt;- setNode(net, card1, nodeType=&quot;dcat&quot;,  pi=vectorProbs(p=cardProbs, card1))
</code></pre>

<pre><code>## Validation has been ignored for parameters defined with character strings
</code></pre>

<pre><code class="r">net &lt;- setNode(net, card2, nodeType=&quot;dcat&quot;,  pi=vectorProbs(p=cardProbs, card2),
               validate=FALSE)
net &lt;- setNode(net, card3, nodeType=&quot;dcat&quot;,  pi=vectorProbs(p=cardProbs, card3),
               validate=FALSE)
net &lt;- setNode(net, card4, nodeType=&quot;dcat&quot;,  pi=vectorProbs(p=cardProbs, card4),
               validate=FALSE)
net &lt;- setNode(net, card5, nodeType=&quot;dcat&quot;,  pi=vectorProbs(p=cardProbs, card5),
               validate=FALSE)

net &lt;- setNode(net, dealerUpcard, nodeType=&quot;dcat&quot;,
               pi=vectorProbs(p=cardProbs, dealerUpcard),
               validate=FALSE)

#Note: node dealerOutcome will be defined below, following some discussion 
#      about its conditional probability distribution.

#####################################
# Deterministic Nodes
#####################################
net &lt;- setNode(net, highUpcard,     &quot;determ&quot;, define=fromFormula(),
               nodeFormula = highUpcard ~ ifelse(dealerUpcard &gt; 8, 1, 0))

net &lt;- setNode(net, initialAces,    &quot;determ&quot;, define=fromFormula(),
               nodeFormula = initialAces ~ ifelse(card1==10,1,0) + ifelse(card2==10,1,0))

net &lt;- setNode(net, acesAfterCard3, &quot;determ&quot;, define=fromFormula(),
               nodeFormula = acesAfterCard3 ~ initialAces + ifelse(card3==10,1,0))

net &lt;- setNode(net, acesAfterCard4, &quot;determ&quot;, define=fromFormula(),
               nodeFormula = acesAfterCard4 ~ acesAfterCard3 + ifelse(card4==10,1,0))

net &lt;- setNode(net, acesAfterCard5, &quot;determ&quot;, define=fromFormula(),
               nodeFormula = acesAfterCard5 ~ acesAfterCard4 + ifelse(card5==10,1,0))

net &lt;- setNode(net, initialPoints, &quot;determ&quot;, define=fromFormula(),
               nodeFormula = initialPoints ~ card1+card2+2)

net &lt;- setNode(net, pointsAfterCard3, &quot;determ&quot;, define=fromFormula(),
               nodeFormula = pointsAfterCard3 ~
                 ifelse(acesAfterCard3 == 3,
                    13,
                    ifelse(acesAfterCard3 == 2,
                       card1 + card2 + card3 + 3 - 10,
                       ifelse(acesAfterCard3 == 1,
                          ifelse(card1 + card2 + card3 + 3 &gt; 22,
                             card1 + card2 + card3 + 3 - 10,
                             card1 + card2 + card3 + 3),
                          card1 + card2 + card3 + 3
                       )
                    )
                 )
              )

net &lt;- setNode(net, pointsAfterCard4, &quot;determ&quot;, define=fromFormula(),
               nodeFormula = pointsAfterCard4 ~
                 ifelse(acesAfterCard4 == 4,
                    14,
                    ifelse(acesAfterCard4 == 3,
                       ifelse(card1 + card2 + card3 + card4 + 4 &gt; 38,
                          card1 + card2 + card3 + card4 + 4 - 30,
                          card1 + card2 + card3 + card4 + 4 - 20
                       ),
                       ifelse(acesAfterCard4 &gt; 0,
                          ifelse(card1 + card2 + card3 + card4 + 4 &gt; 22,
                                 card1 + card2 + card3 + card4 + 4 - 10,
                                 card1 + card2 + card3 + card4 + 4
                          ),
                          card1 + card2 + card3 + card4 + 4
                       )
                    )
                 )
              )

net &lt;- setNode(net, pointsAfterCard5, &quot;determ&quot;, define=fromFormula(),
               nodeFormula = pointsAfterCard5 ~ 
                 ifelse(acesAfterCard5 == 5,
                    15,
                    ifelse(acesAfterCard5 == 4,
                       ifelse(card1 + card2 + card3 + card4 + card5 + 5 &gt; 51,
                          card1 + card2 + card3 + card4 + card5 + 5 - 40,
                          card1 + card2 + card3 + card4 + card5 + 5 - 30
                        ),
                       ifelse(acesAfterCard5 == 3,
                          ifelse(card1 + card2 + card3 + card4 + card5 + 5 &gt; 51,
                             card1 + card2 + card3 + card4 + card5 + 5 - 30,
                             card1 + card2 + card3 + card4 + card5 + 5 - 20
                          ),
                          ifelse(acesAfterCard5 == 2,
                             ifelse(card1 + card2 + card3 + card4 + card5 + 5 &gt; 31,
                                card1 + card2 + card3 + card4 + card5 + 5 - 20,
                                card1 + card2 + card3 + card4 + card5 + 5 - 10
                             ),
                             ifelse(acesAfterCard5 &gt; 0,
                                ifelse(card1 + card2 + card3 + card4 + card5 + 5 &gt; 22,
                                   card1 + card2 + card3 + card4 + card5 + 5 - 10,
                                   card1 + card2 + card3 + card4 + card5 + 5
                                ),
                                card1 + card2 + card3 + card4 + card5 + 5
                             )
                          )
                       )
                    )
                 )
              )

net &lt;- setNode(net, playerFinalPoints, &quot;determ&quot;, define=fromFormula(),
               nodeFormula = playerFinalPoints ~ 
                 ifelse(hit1 == 0,
                    initialPoints,
                    ifelse(hit2 == 0,
                           pointsAfterCard3,
                           ifelse(hit3 == 0, pointsAfterCard4, pointsAfterCard5)
                    )
                 )
              )
</code></pre>

<p>Node distributions for all random variable &amp; deterministic nodes are now specified, other than <code>dealerOutcome</code>. We have included a dataset containing the conditional probability distribution of <code>dealerOutcome</code> given <code>dealerUpcard</code> in the data frame <code>BJDealer</code> (<em>source: <a href="https://www.blackjackinfo.com/dealer-outcome-probabilities">https://www.blackjackinfo.com/dealer-outcome-probabilities</a>. Accessed 2015-04-24.</em>). (These conditional probabilities assume that the dealer is drawing from a deck of infinite size.)</p>

<p>We will use the <code>cpt()</code> function to obtain an array that contains the conditional probabilities of <code>dealerOutcome</code> given <code>dealerUpcard</code>. This array has class <code>cpt</code> and can be fed into JAGS via <code>setNodeModels</code>:</p>

<pre><code class="r">data(BJDealer)
dealerOutcome.cpt &lt;- cpt(dealerOutcome ~ dealerUpcard,
                         data = BJDealer,
                         wt   = BJDealer$probability)
round(dealerOutcome.cpt,3)
</code></pre>

<pre><code>##             dealerOutcome
## dealerUpcard Blackjack  Bust    17    18    19    20    21
##         2        0.000 0.357 0.130 0.137 0.131 0.126 0.120
##         3        0.000 0.377 0.126 0.132 0.127 0.122 0.116
##         4        0.000 0.397 0.122 0.127 0.123 0.118 0.113
##         5        0.000 0.418 0.118 0.123 0.118 0.114 0.109
##         6        0.000 0.440 0.115 0.115 0.115 0.110 0.106
##         7        0.000 0.262 0.369 0.138 0.079 0.079 0.074
##         8        0.000 0.245 0.129 0.359 0.129 0.069 0.069
##         9        0.000 0.228 0.120 0.120 0.351 0.120 0.061
##         10-K     0.071 0.213 0.112 0.112 0.112 0.344 0.035
##         A        0.235 0.153 0.063 0.158 0.158 0.158 0.073
</code></pre>

<pre><code class="r">net &lt;- setNodeModels(net, dealerOutcome.cpt)
</code></pre>

<p>With this work completed, we will now proceed to designating the decision and utility nodes and populating their node distributions (or functions, in the case of deterministic nodes).</p>

<p>The first thing we will do is identify the decision and utility nodes, using the functions <code>setDecisionNodes()</code> and <code>setUtilityNodes()</code>. These functions merely set flags within the <code>HydeNetwork</code> object, to be used in the plot method for <code>HydeNetwork</code> objects as well as in later computations (e.g., computing expected utility of a decision):</p>

<pre><code class="r">net &lt;- setDecisionNodes(net, hit1, hit2, hit3)
net &lt;- setUtilityNodes(net, payoff)

c(net$nodeDecision$hit2, net$nodeUtility$payoff)
</code></pre>

<pre><code>## [1] TRUE TRUE
</code></pre>

<p>We are now ready to visualize the finished decision network:</p>

<pre><code class="r">plot(net)
</code></pre>

<p>&lt;!&ndash;html_preserve&ndash;&gt;<div id="htmlwidget-5867" style="width:504px;height:504px;" class="grViz"></div>
<script type="application/json" data-for="htmlwidget-5867">{&quot;x&quot;:{&quot;diagram&quot;:&quot;digraph {\n\n  \&quot;initialAces\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;gray70\&quot;, color = \&quot;gray70\&quot;, style = \&quot;filled\&quot;] \n  \&quot;card1\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;card2\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;initialPoints\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;gray70\&quot;, color = \&quot;gray70\&quot;, style = \&quot;filled\&quot;] \n  \&quot;highUpcard\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;gray70\&quot;, color = \&quot;gray70\&quot;, style = \&quot;filled\&quot;] \n  \&quot;dealerUpcard\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;hit1\&quot; [fillcolor = \&quot;#6BAED6\&quot;, shape = \&quot;rect\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;acesAfterCard3\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;gray70\&quot;, color = \&quot;gray70\&quot;, style = \&quot;filled\&quot;] \n  \&quot;card3\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;pointsAfterCard3\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;gray70\&quot;, color = \&quot;gray70\&quot;, style = \&quot;filled\&quot;] \n  \&quot;hit2\&quot; [fillcolor = \&quot;#6BAED6\&quot;, shape = \&quot;rect\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;acesAfterCard4\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;gray70\&quot;, color = \&quot;gray70\&quot;, style = \&quot;filled\&quot;] \n  \&quot;card4\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;pointsAfterCard4\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;gray70\&quot;, color = \&quot;gray70\&quot;, style = \&quot;filled\&quot;] \n  \&quot;hit3\&quot; [fillcolor = \&quot;#6BAED6\&quot;, shape = \&quot;rect\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;acesAfterCard5\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;gray70\&quot;, color = \&quot;gray70\&quot;, style = \&quot;filled\&quot;] \n  \&quot;card5\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;pointsAfterCard5\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;gray70\&quot;, color = \&quot;gray70\&quot;, style = \&quot;filled\&quot;] \n  \&quot;playerFinalPoints\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;gray70\&quot;, color = \&quot;gray70\&quot;, style = \&quot;filled\&quot;] \n  \&quot;dealerOutcome\&quot; [fillcolor = \&quot;white\&quot;, shape = \&quot;ellipse\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;payoff\&quot; [fillcolor = \&quot;#FFFFB2\&quot;, shape = \&quot;rect\&quot;, fontcolor = \&quot;black\&quot;, color = \&quot;black\&quot;, style = \&quot;filled\&quot;] \n  \&quot;card1\&quot;-&gt;\&quot;initialAces\&quot; \n  \&quot;card2\&quot;-&gt;\&quot;initialAces\&quot; \n  \&quot;card1\&quot;-&gt;\&quot;initialPoints\&quot; \n  \&quot;card2\&quot;-&gt;\&quot;initialPoints\&quot; \n  \&quot;dealerUpcard\&quot;-&gt;\&quot;highUpcard\&quot; \n  \&quot;initialPoints\&quot;-&gt;\&quot;hit1\&quot; \n  \&quot;highUpcard\&quot;-&gt;\&quot;hit1\&quot; \n  \&quot;initialAces\&quot;-&gt;\&quot;acesAfterCard3\&quot; \n  \&quot;card3\&quot;-&gt;\&quot;acesAfterCard3\&quot; \n  \&quot;card1\&quot;-&gt;\&quot;pointsAfterCard3\&quot; \n  \&quot;card2\&quot;-&gt;\&quot;pointsAfterCard3\&quot; \n  \&quot;acesAfterCard3\&quot;-&gt;\&quot;pointsAfterCard3\&quot; \n  \&quot;card3\&quot;-&gt;\&quot;pointsAfterCard3\&quot; \n  \&quot;highUpcard\&quot;-&gt;\&quot;hit2\&quot; \n  \&quot;pointsAfterCard3\&quot;-&gt;\&quot;hit2\&quot; \n  \&quot;acesAfterCard3\&quot;-&gt;\&quot;acesAfterCard4\&quot; \n  \&quot;card4\&quot;-&gt;\&quot;acesAfterCard4\&quot; \n  \&quot;card1\&quot;-&gt;\&quot;pointsAfterCard4\&quot; \n  \&quot;card2\&quot;-&gt;\&quot;pointsAfterCard4\&quot; \n  \&quot;card3\&quot;-&gt;\&quot;pointsAfterCard4\&quot; \n  \&quot;acesAfterCard4\&quot;-&gt;\&quot;pointsAfterCard4\&quot; \n  \&quot;card4\&quot;-&gt;\&quot;pointsAfterCard4\&quot; \n  \&quot;highUpcard\&quot;-&gt;\&quot;hit3\&quot; \n  \&quot;pointsAfterCard4\&quot;-&gt;\&quot;hit3\&quot; \n  \&quot;acesAfterCard4\&quot;-&gt;\&quot;acesAfterCard5\&quot; \n  \&quot;card5\&quot;-&gt;\&quot;acesAfterCard5\&quot; \n  \&quot;card1\&quot;-&gt;\&quot;pointsAfterCard5\&quot; \n  \&quot;card2\&quot;-&gt;\&quot;pointsAfterCard5\&quot; \n  \&quot;card3\&quot;-&gt;\&quot;pointsAfterCard5\&quot; \n  \&quot;card4\&quot;-&gt;\&quot;pointsAfterCard5\&quot; \n  \&quot;acesAfterCard5\&quot;-&gt;\&quot;pointsAfterCard5\&quot; \n  \&quot;card5\&quot;-&gt;\&quot;pointsAfterCard5\&quot; \n  \&quot;initialPoints\&quot;-&gt;\&quot;playerFinalPoints\&quot; \n  \&quot;hit1\&quot;-&gt;\&quot;playerFinalPoints\&quot; \n  \&quot;pointsAfterCard3\&quot;-&gt;\&quot;playerFinalPoints\&quot; \n  \&quot;hit2\&quot;-&gt;\&quot;playerFinalPoints\&quot; \n  \&quot;pointsAfterCard4\&quot;-&gt;\&quot;playerFinalPoints\&quot; \n  \&quot;hit3\&quot;-&gt;\&quot;playerFinalPoints\&quot; \n  \&quot;pointsAfterCard5\&quot;-&gt;\&quot;playerFinalPoints\&quot; \n  \&quot;dealerUpcard\&quot;-&gt;\&quot;dealerOutcome\&quot; \n  \&quot;playerFinalPoints\&quot;-&gt;\&quot;payoff\&quot; \n  \&quot;dealerOutcome\&quot;-&gt;\&quot;payoff\&quot; \n}&quot;,&quot;config&quot;:{&quot;engine&quot;:&quot;dot&quot;,&quot;options&quot;:null}},&quot;evals&quot;:[]}</script>&lt;!&ndash;/html_preserve&ndash;&gt;</p>

<h2>Decision and Utility Nodes</h2>

<p><strong>Decision nodes</strong> can be thought of as ordinary nodes and fed into JAGS just as we would normally. We thus would populate their conditional distributions and/or deterministic functions in the same way that we&#39;re used to doing so. The reason we flag decision and utility nodes is that doing so allows us to conduct analyses which seek to maximize expected utility as it relates to decision-making strategies. Decision nodes therefore are assumed to be <em>manipulable</em> by the actor. We refer to a specific combination of decision nodes &ndash; or a rule that dictates how decision nodes get assigned in response to observation of relevant information &ndash; as a <em>policy</em>.</p>

<p>Decision nodes must have children nodes, and for every decision node in the network, there must be at least one utility node that is a decendant of it (although these need not be unique). When decision nodes have parents, the implication is that the parent nodes provide <em>information</em> that is used to guide the process of decision-making for that node. Hence, these links are called <em>information links</em>. For decision nodes that are random variables, we can think of their conditional probability distribution as a frequency (or, alternatively, a representation of belief) of observed decisions under distinct combinations of parent nodes within a population. For example, we may have data on observed hit/stand decisions in blackjack, from which logistic regression models can be estimated to characterize the relationship between point totals at certain hit decisions and probability of deciding to take another card.</p>

<p>Below, we make such models and incorporate them into the network. We have simplified dealer upcard information into a binary variable for this decision.</p>

<pre><code class="r">data(BlackJackTrain)
BlackJackTrain$highUpcard &lt;- as.character(BlackJackTrain$dealerUpcard)
BlackJackTrain$highUpcard &lt;- factor(BlackJackTrain$highUpcard %in% c(&quot;10-K&quot;,&quot;A&quot;),
                                    c(FALSE, TRUE), c(&quot;9 or lower&quot;, &quot;10 or higher&quot;))

# glm.hit1 &lt;- glm(hit1 ~ initialPoints + I(dealerUpcard %in% c(&quot;9&quot;,&quot;10-K&quot;,&quot;A&quot;)),
#                 data = BlackJackTrain, family=&quot;binomial&quot;)

glm.hit1 &lt;- glm(hit1 ~ initialPoints+highUpcard,
                data = BlackJackTrain, family=&quot;binomial&quot;)
glm.hit2 &lt;- glm(hit2 ~ pointsAfterCard3+highUpcard,
                data = BlackJackTrain, family=&quot;binomial&quot;)
glm.hit3 &lt;- glm(hit3 ~ pointsAfterCard4+highUpcard,
                data = BlackJackTrain, family=&quot;binomial&quot;)

net &lt;- setNodeModels(net, glm.hit1, glm.hit2, glm.hit3)
</code></pre>

<p>Alternatively, decision nodes can be deterministic in nature. In this case, we interpret the function which sets the value of these nodes depending on the value(s) of its parent node(s) as a deterministic strategy that is chosen by the actor. Within the blackjack network, we might envision such a strategy by the following rule, which would be applicable to all three hit decisions in the network: choose &#39;hit&#39; when the current point total is less than 15.</p>

<p><strong>Utility nodes</strong> are restricted to be deterministic nodes with no descendents. In the blackjack example, for instance, we would assign the payoff utility node as follows:</p>

<pre><code class="r">net &lt;- setNode(net, payoff, &quot;determ&quot;, define=fromFormula(),
         nodeFormula = payoff ~
                         ifelse(playerFinalPoints &gt; 21, -1,
                           ifelse(playerFinalPoints == 21,
                             ifelse(dealerOutcome == 1, 0,
                               ifelse(dealerOutcome == 7, 0, 1)),
                             ifelse(dealerOutcome == 2,
                               ifelse(playerFinalPoints &lt; 22, 1, -1),
                               ifelse(dealerOutcome == 3,
                                 ifelse(playerFinalPoints == 17, 0,
                                 ifelse(playerFinalPoints &gt; 17, 1, -1)),
                                 ifelse(dealerOutcome == 4,
                                   ifelse(playerFinalPoints == 18, 0,
                                     ifelse(playerFinalPoints &gt; 18, 1, -1)),
                                   ifelse(dealerOutcome == 5,
                                     ifelse(playerFinalPoints == 19, 0,
                                       ifelse(playerFinalPoints &gt; 19, 1, -1)),
                                     ifelse(dealerOutcome == 6,
                                       ifelse(playerFinalPoints == 20, 0,
                                         ifelse(playerFinalPoints &gt; 20, 1, -1)),
                                       ifelse(playerFinalPoints == 21, 0, -1)))))))))
</code></pre>

<p>The network model is now fully specified. This can be treated as an ordinary Bayesian network, ignoring the fact that some nodes represent decisions or utilites. For example, we can compile the network and feed it to JAGS with some evidence to obtain a MCMC sample of the joint posterior distribution of the unobserved nodes:</p>

<pre><code class="r">trackedVars &lt;- c(&quot;dealerUpcard&quot;,&quot;playerFinalPoints&quot;,&quot;dealerOutcome&quot;,&quot;payoff&quot;)
evidence &lt;- list(card1 = 3)
compiledNet &lt;- compileJagsModel(net, data = evidence,
                                n.chains = 3,
                                n.adapt = 5000)
</code></pre>

<pre><code>## Compiling model graph
##    Resolving undeclared variables
##    Allocating nodes
##    Graph Size: 313
## 
## Initializing model
</code></pre>

<pre><code class="r">post &lt;- HydePosterior(compiledNet,
                      variable.names = trackedVars,
                      n.iter=10000)
post &lt;- bindPosterior(post)

dplyr::sample_n(post, 20)
</code></pre>

<pre><code>##       card1 dealerOutcome dealerUpcard payoff playerFinalPoints
## 7768      3            17            7     -1                14
## 509       3            18            4     -1                12
## 26076     3            20         10-K     -1                14
## 12099     3          Bust            6      1                14
## 2724      3            18         10-K     -1                14
## 10643     3          Bust         10-K      1                19
## 3757      3          Bust         10-K     -1                24
## 1796      3            20            5     -1                14
## 1868      3            18            7     -1                13
## 29948     3            20            A     -1                14
## 27439     3            21            7     -1                17
## 28831     3            17            6     -1                15
## 20931     3          Bust            2     -1                22
## 20788     3            19         10-K     -1                17
## 9461      3            18            4     -1                17
## 3872      3            20            A      1                21
## 3980      3          Bust            6      1                21
## 1552      3            18         10-K     -1                17
## 28854     3            20            2     -1                13
## 11820     3          Bust         10-K      1                14
</code></pre>

<p>And, we can do things like compute expected utility (under the distribution of hit decisions observed in the sample, i.e., absent any specific hit strategy) when dealt a 3:</p>

<pre><code class="r">table(post$payoff)
</code></pre>

<pre><code>## 
##    -1     0     1 
## 22868  1267  5865
</code></pre>

<pre><code class="r">mean(post$payoff)
</code></pre>

<pre><code>## [1] -0.5667667
</code></pre>

<h2>Maximum Expected Utility Analysis</h2>

<p>In a maximum expected utility analysis, the goal is to compare different decision-making strategies, known as <em>policies</em>, in order to identify which one yields the greatest expected reward. With respect to our decision networks, this amounts to running the MCMC sampler with decision nodes set at specific values to get a representation of the joint posterior distribution of the utility nodes, and then adding their values to get a posterior distribution of total utility (from which we can get expected values, modes, etc.). We demonstrate this process below using the Blackjack network.</p>

<p>We will analyze the following four strategies: never choose to &ldquo;hit&rdquo;, always take 3 cards, always take 4 cards, and always take 5 cards. Our set of discrete combinations of decision nodes can be represented by a <em>policy matrix</em>:</p>

<pre><code class="r">policies &lt;- data.frame(hit1 = c(0,1,1,1),
                       hit2 = c(0,0,1,1),
                       hit3 = c(0,0,0,1))
</code></pre>

<p>(Note: we have included a convenience function called <code>policyMatrix()</code> when all combinations of decision node values are of interest. This function is a wrapper for <code>expand.grid()</code>; see <code>help(policyMatrix)</code> for details.)</p>

<p>In the MEU analysis, the goal is to characterize the distribution of utility under the competing policies. This amounts to sampling posterior distributions of utility nodes under varying sets of values for the decision nodes. In <code>HydeNet</code>, this is done by 1) using the function <code>compileDecisionModel()</code> to create a list of <code>compiledHydeNetwork</code> objects (one object corresponding to each policy); 2) feeding that list to <code>HydePosterior()</code> to get a list of <code>coda.samples</code> objects; and finally 3) feeding the list of <code>coda.samples</code> objects to <code>bindPosterior()</code> to get a single posterior sample matrix for each policy:</p>

<pre><code class="r">compiledNets &lt;- compileDecisionModel(net, policyMatrix = policies)
</code></pre>

<pre><code>## Compiling model graph
##    Resolving undeclared variables
##    Allocating nodes
##    Graph Size: 313
## 
## Initializing model
## 
## Compiling model graph
##    Resolving undeclared variables
##    Allocating nodes
##    Graph Size: 311
## 
## Initializing model
## 
## Compiling model graph
##    Resolving undeclared variables
##    Allocating nodes
##    Graph Size: 312
## 
## Initializing model
## 
## Compiling model graph
##    Resolving undeclared variables
##    Allocating nodes
##    Graph Size: 312
## 
## Initializing model
## 
## Compiling model graph
##    Resolving undeclared variables
##    Allocating nodes
##    Graph Size: 311
## 
## Initializing model
</code></pre>

<pre><code class="r">samples &lt;- lapply(compiledNets,
                  HydePosterior,
                  variable.names = trackedVars,
                  n.iter=100000)

samples &lt;- lapply(samples, bindPosterior)

lapply(samples, head)
</code></pre>

<pre><code>## [[1]]
##   dealerOutcome dealerUpcard hit1 hit2 hit3 payoff playerFinalPoints
## 1            17         10-K    0    0    0      1                20
## 2            17            9    0    0    0     -1                15
## 3            18            2    0    0    0      1                20
## 4            21            2    0    0    0     -1                12
## 5            20         10-K    0    0    0     -1                14
## 6            19            7    0    0    0     -1                13
## 
## [[2]]
##   dealerOutcome dealerUpcard hit1 hit2 hit3 payoff playerFinalPoints
## 1            21            6    1    0    0     -1                19
## 2     Blackjack            5    1    0    0     -1                15
## 3     Blackjack            5    1    0    0     -1                16
## 4            19            9    1    0    0     -1                17
## 5            18            8    1    0    0     -1                22
## 6            20            3    1    0    0     -1                22
## 
## [[3]]
##   dealerOutcome dealerUpcard hit1 hit2 hit3 payoff playerFinalPoints
## 1          Bust         10-K    1    1    0      1                16
## 2            19            9    1    1    0     -1                24
## 3            19            9    1    1    0     -1                18
## 4            18            5    1    1    0     -1                27
## 5            19         10-K    1    1    0      1                20
## 6            19            4    1    1    0     -1                18
## 
## [[4]]
##   dealerOutcome dealerUpcard hit1 hit2 hit3 payoff playerFinalPoints
## 1     Blackjack            8    1    1    1     -1                19
## 2            18            4    1    1    1     -1                26
## 3            17            6    1    1    1     -1                15
## 4          Bust            2    1    1    1     -1                23
## 5            20            7    1    1    1      0                20
## 6          Bust            4    1    1    1      1                20
</code></pre>

<p>We now have a list of data frames, each data frame corresponding to one of the four hit policies (never hit, hit once, hit twice, and hit three times). Straightforward manipulations allow for examination of expected utility:</p>

<pre><code class="r">#summary of expected utility under each policy
lapply(samples, function(l) mean(l$payoff))
</code></pre>

<pre><code>## [[1]]
## [1] -0.35794
## 
## [[2]]
## [1] -0.4234
## 
## [[3]]
## [1] -0.42229
## 
## [[4]]
## [1] -0.48251
</code></pre>

<p>We see that, among these four strategies, taking no cards appears to maximize expected utility (i.e., leads to losing the least amount of money.</p>

<!--

## Value of Information Analysis

XXXXX

## Asymmetric Decision Problems

decision networks are tricky business. 3 types of asymmetry in decision networks. Currently, our package only allows for fully symmetric decision networks or networks that exhibit order asymmetry. However, careful use of the package to evaluate other situations is possible. We give some general guidance below on how to think about decision processes:

Decision/data process:  (A1, D1, A2, D2, ..., A_n-1, D_n-1, An)

-->

</body>

</html>
